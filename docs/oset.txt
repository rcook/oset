-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An insertion-order-preserving set
--   
--   This package provides <tt>OSet</tt>, an insertion-order-preserving
--   set, with type class instances for <tt>Foldable</tt>,
--   <tt>Semigroup</tt>, <tt>Monoid</tt> and <tt>Data</tt>.
@package oset
@version 0.1.0.0


-- | This module provides <a>OSet</a>, an insertion-order-preserving set,
--   with type class instances for <a>Foldable</a>, <a>Semigroup</a>,
--   <a>Monoid</a> and <a>Data</a> as well as a <a>map</a> function.
--   
--   This is intended to be API-compatible with <a>OSet</a> in
--   <a>unordered-containers</a> but with a few extra type class instances.
--   
--   Here's the quick-start guide to using this package:
--   
--   <pre>
--   module Main (main) where
--   
--   import           Data.Set.Ordered ((|&gt;), (|&lt;))
--   import qualified Data.Set.Ordered as OSet
--   
--   main :: IO ()
--   main = do
--       -- Create from list
--       let s0 = OSet.fromList [1 :: Int, 2, 3, 4, 4, 3, 2, 1, -1, -2, -3]
--       print s0 -- outputs: "fromList [1,2,3,4,-1,-2,-3]"
--   
--       -- Append
--       let s1 = s0 |&gt; 4
--       print s1 -- outputs: "fromList [1,2,3,4,-1,-2,-3]"
--   
--       -- Prepend
--       let s2 = 4 |&lt; s0
--       print s2 -- outputs: "fromList [4,1,2,3,-1,-2,-3]"
--   
--       -- Semigroup
--       let s3 = s0 &lt;&gt; OSet.fromList [10, 10, 20, 20, 30, 30]
--       print s3 -- outputs: "fromList [1,2,3,4,-1,-2,-3,10,20,30]"
--   
--       -- Map (but note that OSet is not a functor)
--       let s4 = OSet.map (\x -&gt; x * x) s3
--       print s4 -- outputs: "fromList [1,4,9,16,100,400,900]"
--   
--       -- Filter
--       let s5 = OSet.filter (&gt;= 100) s4
--       print s5 -- outputs: "fromList [100,400,900]"
--   </pre>
--   
--   There are cases where the developer's natural instinct would be to
--   convert the <a>OSet</a> instance to a list using <a>toList</a> from
--   <a>Foldable</a>. While this is possible, it will often be more
--   efficient to use <a>toSeq</a> and operate on the sequence that way.
--   You can even use view patterns to pattern-match on the resulting
--   sequence:
--   
--   <pre>
--   module Main (main) where
--   
--   import           Data.Sequence (ViewL(..), viewl)
--   import           Data.Set.Ordered (OSet)
--   import qualified Data.Set.Ordered as OSet
--   
--   showFromLeft :: Show a =&gt; OSet a -&gt; String
--   showFromLeft o = go (OSet.toSeq o)
--       where
--           go (viewl -&gt; EmptyL) = ""
--           go (viewl -&gt; h :&lt; t) = show h ++ go t
--           go _ = error "Should not happen" -- suppress warning about non-exhaustive patterns
--   
--   main :: IO ()
--   main = do
--       let a = OSet.fromList [4 :: Int, 1, 3, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
--       print $ showFromLeft a -- outputs: "4139025678"
--   </pre>
module Data.Set.Ordered

-- | &lt;math&gt;. Append an element to the end of set if the set does not
--   already contain the element. The element is ignored if it is already
--   in the set.
(|>) :: Ord a => OSet a -> a -> OSet a
infixl 5 |>

-- | &lt;math&gt; if the element is not in the set, &lt;math&gt; if the
--   element is already in the set. Prepend an element to the head of the
--   set if the set does not already contain the element. The element is
--   moved to the head of the sequence if the element is already present in
--   the set.
(|<) :: Ord a => a -> OSet a -> OSet a
infixr 5 |<

-- | An <a>OSet</a> behaves much like a <a>Set</a> but remembers the order
--   in which the elements were originally inserted.
data OSet a

-- | &lt;math&gt;. The empty set.
empty :: OSet a

-- | &lt;math&gt;. Filter a set by returning a set whose elements satisfy
--   the predicate.
filter :: (a -> Bool) -> OSet a -> OSet a

-- | &lt;math&gt;. Create a set from a finite list of elements. If an
--   element occurs multiple times in the original list, only the first
--   occurrence is retained in the resulting set. The function
--   <a>toList</a>, &lt;math&gt;, in <a>Foldable</a> can be used to return
--   a list of the elements in the original insert order with duplicates
--   removed.
fromList :: Ord a => [a] -> OSet a

-- | &lt;math&gt;. Return the set obtained by applying a function to each
--   element of this set. Note that the resulting set may be smaller than
--   the original. Along with the <a>Ord</a> constraint, this means that
--   <a>OSet</a> cannot provide a lawful <tt>Functor</tt> instance.
map :: Ord b => (a -> b) -> OSet a -> OSet b

-- | &lt;math&gt;. Determine if the element is in the set.
member :: Ord a => a -> OSet a -> Bool

-- | &lt;math&gt;. Determine if the element is not in the set.
notMember :: Ord a => a -> OSet a -> Bool

-- | &lt;math&gt;. A singleton set containing the given element.
singleton :: a -> OSet a

-- | &lt;math&gt;. Return ordered sequence of elements in set. For
--   obtaining a useful <tt>Functor</tt> this is recommended over
--   <a>toList</a> due to its constant-time performance. Similarly, if you
--   want to pattern-match on the <a>OSet</a>, obtain the sequence and use
--   view patterns instead of converting to a list.
toSeq :: OSet a -> Seq a
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Set.Ordered.OSet a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Set.Ordered.OSet a)
instance (Data.Data.Data a, GHC.Classes.Ord a) => Data.Data.Data (Data.Set.Ordered.OSet a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Set.Ordered.OSet a)
instance Data.Foldable.Foldable Data.Set.Ordered.OSet
instance GHC.Classes.Ord a => GHC.Base.Semigroup (Data.Set.Ordered.OSet a)
instance GHC.Classes.Ord a => GHC.Base.Monoid (Data.Set.Ordered.OSet a)
