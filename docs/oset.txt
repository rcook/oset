-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An insertion-order-preserving set
--   
--   This package provides <tt>OSet</tt>, an insertion-order-preserving
--   set, with type class instances for <tt>Foldable</tt>,
--   <tt>Semigroup</tt>, <tt>Monoid</tt> and <tt>Data</tt>.
@package oset
@version 0.1.0.0


-- | This module provides <tt>OSet</tt>, an insertion-order-preserving set,
--   with type class instances for <tt>Foldable</tt>, <tt>Semigroup</tt>,
--   <tt>Monoid</tt> and <tt>Data</tt> as well as a <tt>map</tt> function.
--   
--   This is intended to be API-compatible with <a>OSet</a> in
--   <a>unordered-containers</a> but with a few extra type class instances.
--   
--   Here's the quick-start guide to using this package:
--   
--   <pre>
--   module Main (main) where
--   
--   import           Data.Set.Ordered ((|&gt;), (|&lt;), OSet)
--   import qualified Data.Set.Ordered as OSet
--   
--   main :: IO ()
--   main = do
--       -- Create from list
--       let s0 = OSet.fromList [1, 2, 3, 4, 4, 3, 2, 1, -1, -2, -3]
--       print s0 -- outputs: "fromList [1,2,3,4,-1,-2,-3]"
--   
--       -- Append
--       let s1 = s0 |&gt; 4
--       print s1 -- outputs: "fromList [1,2,3,4,-1,-2,-3]"
--   
--       -- Prepend
--       let s2 = 4 |&lt; s0
--       print s2 -- outputs: "fromList [4,1,2,3,-1,-2,-3]"
--   
--       -- Semigroup
--       let s3 = s0 &lt;&gt; OSet.fromList [10, 10, 20, 20, 30, 30]
--       print s3 -- outputs: "fromList [1,2,3,4,-1,-2,-3,10,20,30]"
--   
--       -- Map (but note that OSet is not a functor)
--       let s4 = OSet.map (\x -&gt; x * x) s3
--       print s4 -- outputs: "fromList [1,4,9,16,100,400,900]"
--   
--       -- Filter
--       let s5 = OSet.filter (&gt;= 100) s4
--       print s5 -- outputs: "fromList [100,400,900]"
--   </pre>
module Data.Set.Ordered

-- | &lt;math&gt;. Append an element to the end of set if the set does not
--   already contain the element. The element is ignored if it is already
--   in the set.
(|>) :: Ord a => OSet a -> a -> OSet a
infixl 5 |>

-- | &lt;math&gt; if the element is not in the set, &lt;math&gt; if the
--   element is already in the set. Prepend an element to the head of the
--   set if the set does not already contain the element. The element is
--   moved to the head of the sequence if the element is already present in
--   the set.
(|<) :: Ord a => a -> OSet a -> OSet a
infixr 5 |<

-- | An <tt>OSet</tt> behaves much like a <tt>Set</tt> but remembers the
--   order in which the elements were originally inserted.
data OSet a

-- | &lt;math&gt;. The empty set.
empty :: OSet a

-- | &lt;math&gt;. Filter a set by returning a set whose elements satisfy
--   the predicate.
filter :: (a -> Bool) -> OSet a -> OSet a

-- | &lt;math&gt;. Create a set from a finite list of elements. If an
--   element occurs multiple times in the original list, only the first
--   occurrence is retained in the resulting set. The function
--   <a>toList</a>, &lt;math&gt;, in <a>Foldable</a> can be used to return
--   a list of the elements in the original insert order with duplicates
--   removed.
fromList :: Ord a => [a] -> OSet a

-- | &lt;math&gt;. Return the set obtained by applying a function to each
--   element of this set. Note that the resulting set may be smaller than
--   the original. Along with the <tt>Ord</tt> constraint, this means that
--   <tt>OSet</tt> cannot provide a lawful <tt>Functor</tt> instance.
map :: Ord b => (a -> b) -> OSet a -> OSet b

-- | &lt;math&gt;. Determine if the element is in the set.
member :: Ord a => a -> OSet a -> Bool

-- | &lt;math&gt;. Determine if the element is not in the set.
notMember :: Ord a => a -> OSet a -> Bool

-- | &lt;math&gt;. A singleton set containing the given element.
singleton :: a -> OSet a
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Set.Ordered.OSet a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Set.Ordered.OSet a)
instance (Data.Data.Data a, GHC.Classes.Ord a) => Data.Data.Data (Data.Set.Ordered.OSet a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Set.Ordered.OSet a)
instance Data.Foldable.Foldable Data.Set.Ordered.OSet
instance GHC.Classes.Ord a => GHC.Base.Semigroup (Data.Set.Ordered.OSet a)
instance GHC.Classes.Ord a => GHC.Base.Monoid (Data.Set.Ordered.OSet a)
